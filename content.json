{"meta":{"title":"点滴","subtitle":"为生活画一幅画像","description":"分享生活，记录学习","author":"Ruby Cao","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2019-03-05T13:28:37.000Z","updated":"2019-03-05T13:30:47.380Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-03-05T13:31:14.000Z","updated":"2019-03-05T13:31:51.828Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"你需要看的《钢之炼金术师》","slug":"你需要看的《钢之炼金术师》","date":"2019-04-06T01:34:37.000Z","updated":"2019-04-06T03:20:06.668Z","comments":true,"path":"2019/04/06/你需要看的《钢之炼金术师》/","link":"","permalink":"http://yoursite.com/2019/04/06/你需要看的《钢之炼金术师》/","excerpt":"今天一早醒来例行公事般的浏览B站，发现B站推了“十年经典动画巡礼Vol.8——钢之炼金术师”。文章写的很好，让我很想回忆我看这部番的感觉。（指路B站）","text":"今天一早醒来例行公事般的浏览B站，发现B站推了“十年经典动画巡礼Vol.8——钢之炼金术师”。文章写的很好，让我很想回忆我看这部番的感觉。（指路B站） 钢炼FA是我唯一一部二刷的番，哪怕他有64集，也丝毫没有阻挡我二刷的脚步。番的设定是因为进行人体炼成而失去身体和灵魂的艾尔利克兄弟的寻回身体的旅程，这部番没有一个宏伟虚无的目标，两兄弟只是为了寻回身体，只是道路从最开始的贤者之石变成了寻求“等价交换”的真谛。 还给我！他是我弟弟。你要腿，还是手，还是心脏，我都给你。所以，还给我，我就这一个亲人了！——第2话：开始之日 作品在开头就把背景交代的很清楚，并且一直在强调作品的核心“等价交换”。 炼金术，是对物质进行理解、分解和再构筑的科学，单并非是万能的技术。炼金术不能无中生有，要得到一种物质，必须付出与之相当的代价，这便是炼金术的基础——等价交换。炼金术师有一禁忌，即人体炼成，任何人皆不得触犯禁忌。——开场白 在作品的开场并没有急着进入主角的寻回身体的主线，而是通过一些致郁的情节告诉观看者：这场追寻真理的旅途，注定布满荆棘。在此期间，反派们也慢慢在作品中出现。这里需要赞叹作者的埋伏笔的能力，在作品的前几集的让反派都露了面（这是我在二刷的时候发现的）。 这部番的反派没有弱智，没有洗白，没有谜之操作，是我无比喜欢的反派。 传说人有七宗罪，色欲，强欲，怠惰，暴食，嫉妒，愤怒，以及傲慢。——第42话：蝼蚁的一啮 作品的反派就是从这七种情感而衍生的人造人以及创造出他们的瓶中小人。可以看出，人造人们除了拥有基本的原罪还拥有更多人的情感。可以把他们看作拥有极端原罪的人。被罗伊烧死的拉斯特，看着为了愈合烧掉伤口，用血画出炼成阵的大佐，最后竟也露出了释然的微笑。（这也是大佐一战成名的原因，一直受到大家的喜爱） 我输了，很不甘心，但死在你这样的男性手下并不算糟。——第19话：不死者之死 被同伴吞噬的暴食库拉托尼，一直都记着拉斯特。 罗伊·马斯坦在哪里！竟敢把拉斯特…不可原谅！——第24话：腹中 擅长变身的恩维，是我特别喜欢的一个角色，也是作品着墨较多的反派。他是嫉妒的化身，嫉妒的是无论经历多少次都会重新振作，周围的人也会彼此支撑的人类。而这样的情感被爱德华所理解。最后在被烧死之前，自杀而死。 你，羡慕这样的人类吧。——第54话：烈火之前 第一个以人类为基础的人造人金·布拉德雷，他作为总统候补人，一直接受着精英教育，在体能达到巅峰的时候被贤者之石，成为第一个活下来的总统候补，所以他的身体也会衰老。他是我同学特别喜欢的一个角色。最后死在斯卡的手下，死前对自己一生并非被父亲大人完全控制感到坦然，亦对自己选择的妻子非常自豪。 虽是在既定的轨迹上走完了一生，不过多亏你们人类，多少…还算有些价值的人生吧。——第61话：噬神者 对同为人造人的手足也无比狠心的兄长普莱德，在弥留之际想到的也是人类父母的面容。一直在违背父亲的古利德，为了姚麟和爱德华等朋友与老爹对抗。每一个反派都嘲笑着人类的渺小和愚蠢，却无法抑制对美丽灵魂的憧憬和期待，这就是反派应该有的形象，而不是为了坏而坏。 战斗的过程总是伴随着牺牲，所以作品里面不会存在永远不死的正派，胡爷爷，修兹，帕卡尼亚，他们并没有白白离去。而活下来的人，带着所有人的期望，继续着没有终点的旅行。 不为原则束缚而追求可能性，也是人类进步的需要。——第52话：大家的力量 作品不得不提到的还有对于暴风雨结束之后的描写，用了整整一话来描写了那种无限美好的希冀。新的旅程一定也会有新的收获，毕竟他们拥有钢铁般的心。作品还有很多精彩的内容没有讲到，希望看到这篇文章的时候，能去B站搜这部番来看。（不说了，我要去三刷了） 还有一些我认为特别需要推荐的日漫在这里记录一次： 进击的巨人 我的入坑番，热血番，强烈推荐，在我心里的位置和钢炼不相上下 命运石之门 科幻番，平行世界的背景 多罗罗 热血/战斗番，是手冢治虫的原作改编 龙与虎 恋爱番，钉宫癌的开始（顺便说一下，钢炼里面的阿尔就是钉宫配的） 豚骨拉面团 制作很穷，但是拥有级棒的剧情和声优 最后（我保证是最后），再推荐钢炼的一首OP：again和一首ED：let it out","categories":[{"name":"live","slug":"live","permalink":"http://yoursite.com/categories/live/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"钢炼FA","slug":"钢炼FA","permalink":"http://yoursite.com/tags/钢炼FA/"},{"name":"动漫","slug":"动漫","permalink":"http://yoursite.com/tags/动漫/"}]},{"title":"*.pem密钥连接服务器","slug":"pem密钥连接服务器","date":"2019-04-04T11:55:39.000Z","updated":"2019-04-04T12:55:12.127Z","comments":true,"path":"2019/04/04/pem密钥连接服务器/","link":"","permalink":"http://yoursite.com/2019/04/04/pem密钥连接服务器/","excerpt":"公司要开始一个新的项目了（撒花~）作为实习生的我终于有机会完整参加一个项目了。今天就遇到了第一个问题，就是打开服务器的问题，总公司的大佬给了我们一个 *.pem 加密文件、一个ip地址以及用户名。拿到的时候真的是一脸懵逼，查来查去找到了两种方法。Let’s go! 采用putty这种方法可以查看菜鸟教程-Linux远程登录。putty随便搜搜就可以下载，所以直接从putty下载完成之后说起。","text":"公司要开始一个新的项目了（撒花~）作为实习生的我终于有机会完整参加一个项目了。今天就遇到了第一个问题，就是打开服务器的问题，总公司的大佬给了我们一个 *.pem 加密文件、一个ip地址以及用户名。拿到的时候真的是一脸懵逼，查来查去找到了两种方法。Let’s go! 采用putty这种方法可以查看菜鸟教程-Linux远程登录。putty随便搜搜就可以下载，所以直接从putty下载完成之后说起。 1.获取*.ppk文件打开PuTTYgen，点击load。把*.pem文件加载进去。点击Save private key 把生成的.ppk文件保存下来。 2.打开服务器点击PuTTY，出现如下界面,填写服务器的IP地址。如下图点击Auth，点击Browse把之前的.ppk文件导入，点击open。之后再输入用户名，就可以进入服务器了。 使用Xshell可以看出使用putty比较繁琐，这时候就要推荐Xshell了。Xshell是一个强大的安全终端模拟软件，可以在Windows界面下用来访问远端不同系统下的服务器，从而比较好的达到远程控制终端的目的。下载也很方便，也直接从配置开始讲。1.首先点击进入Xshell界面，会自动弹出会话，点击新建。出现如下图的界面，填写IP地址。2.接下来进行用户身份验证。方法记得要选Public Key。3.点击浏览，导入.pem文件。4.点击连接，就出现下图界面，输入用户名就可以进入服务器了。 Xftp的使用前面是终端仿真软件，都建议搭配Xftp使用。Xftp是一个用于MS Windows平台的强大的FTP和SFTP文件传输程序。Xftp能安全地在Unix/Linux和Windows PC之间传输文件，主要作用就是拷贝文件。下载也很方便，配置方法和Xshell一模一样，从名字也可以看出来是一家公司的（哈哈~）","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"服务器","slug":"服务器","permalink":"http://yoursite.com/tags/服务器/"},{"name":"putty","slug":"putty","permalink":"http://yoursite.com/tags/putty/"},{"name":"Xshell","slug":"Xshell","permalink":"http://yoursite.com/tags/Xshell/"}]},{"title":"考研记-1","slug":"考研记-1","date":"2019-04-03T02:20:14.000Z","updated":"2019-04-03T02:30:30.938Z","comments":true,"path":"2019/04/03/考研记-1/","link":"","permalink":"http://yoursite.com/2019/04/03/考研记-1/","excerpt":"因为最近在准备考研，昨天听朱伟老师的恋练有词网课，老师分享了两句话，觉得很有意思，所以想记录一下。 If you want to conquer fast, don’t sit home and think about it. Go out and get busy. 这句话出自 Dale Carnegie (戴尔·卡耐基)，他是美国著名的作家，心理学家，人际关系学家。","text":"因为最近在准备考研，昨天听朱伟老师的恋练有词网课，老师分享了两句话，觉得很有意思，所以想记录一下。 If you want to conquer fast, don’t sit home and think about it. Go out and get busy. 这句话出自 Dale Carnegie (戴尔·卡耐基)，他是美国著名的作家，心理学家，人际关系学家。 The way to become rich is to put all your eggs in one basket and then watch that basket. 这句话出自 Andrew Carnegie (安德鲁·卡耐基)，他是美国实业家、慈善家，卡耐基钢铁公司的创始人，被世人誉为“钢铁大王”。 看到这两句话，我很容易就想到了王国维的人生三种境界的前两种： 昨夜西风凋碧树，独上高楼，望断天涯路，此第一境也，衣带渐宽终不悔，为伊消得人憔悴，此第二境也，众里寻他千百度，蓦然回首，那人却在灯火阑珊处，此第三境也。 (说到《人间词话》最著名的大概就是这句话，但是这本书最重要的东西并不是这三种境界，而是通过词话叩问人生)可以看出，戴尔·卡耐基所说的“瞎忙”可以对应第一境。但是这绝不是普通的“瞎忙”，而是通过“瞎忙”找到最适合自己的路，找到自己的兴趣点。然后就是奉行安德鲁·卡耐基所对应的第二境，坚定不移的走下去。中国有句俗语，不要把所有鸡蛋放在一个篮子里。需要明白的是，人的精力是有限的，当你分配的精力不足时，你很难做成一件事。其实考研也是一样的呀~继续去听老师的网课了（溜走~）","categories":[{"name":"考研","slug":"考研","permalink":"http://yoursite.com/categories/考研/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"句子","slug":"句子","permalink":"http://yoursite.com/tags/句子/"}]},{"title":"基于springboot搭建webservice","slug":"基于springboot搭建webservice","date":"2019-04-03T01:23:23.000Z","updated":"2019-04-03T01:54:49.542Z","comments":true,"path":"2019/04/03/基于springboot搭建webservice/","link":"","permalink":"http://yoursite.com/2019/04/03/基于springboot搭建webservice/","excerpt":"使用springboot + cxf 搭建webservice服务端 1.添加依赖在pom.xml中添加webservice cxf依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt;&lt;/dependency&gt;","text":"使用springboot + cxf 搭建webservice服务端 1.添加依赖在pom.xml中添加webservice cxf依赖12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt; &lt;artifactId&gt;cxf-rt-transports-http&lt;/artifactId&gt; &lt;version&gt;3.1.6&lt;/version&gt;&lt;/dependency&gt; 2.构建并实现服务接口这里只是记录搭建的步骤，所以采用返回一个固定字符串的方法。写一个简单的接口。 12345678910@WebServicepublic interface TestService &#123; @WebMethod //不带参数 public String sayHello(); @WebMethod //带参数 public Position sayHello(@WebParam(name = \"name\") String name);&#125; 接下来实现接口 12345678910111213141516171819@WebService(targetNamespace = \"http://service.yitengtech.com\",endpointInterface = \"com.yitengtech.service.TestService\")@Componentpublic class TestServiceImpl implements TestService &#123; @Override public String sayHello() &#123; // TODO Auto-generated method stub return \"hello \"; &#125; @Override public String sayHello(String name) &#123; // TODO Auto-generated method stub return \"hello \" + name; &#125;&#125; 注： targetNamespace为包名的反序 endpointInterface是当前需要实现接口的全称 3.服务发布类123456789101112131415161718192021222324252627282930313233@Configurationpublic class CxfConfig &#123; @SuppressWarnings(&#123; \"rawtypes\", \"unchecked\" &#125;) @Bean public ServletRegistrationBean dispatcherServlet()&#123; return new ServletRegistrationBean(new CXFServlet(),\"/service/*\");//发布服务名称 &#125; @Bean(name = Bus.DEFAULT_BUS_ID) public SpringBus springBus() &#123; return new SpringBus(); &#125; @Bean public TestService testService() &#123; return new TestServiceImpl(); &#125;// @Autowired// private Bus bus;// // @Autowired// private TestService service; @Bean public Endpoint endpoint() &#123; EndpointImpl endpoint=new EndpointImpl(springBus(), testService());//绑定要发布的服务 endpoint.publish(\"/test\"); //显示要发布的名称 return endpoint; &#125;&#125; 注： 如果需要发布多个webservice，需要配置多个Config实现类文件； 运行程序，输入 http://localhost:8080/service/test?wsdl 即可查询发布出去的接口文件；测试方法可以通过 http://localhost:8080/service/test?wsdl 查看接口文件 （这里采用了postman测试，也可以直接在浏览器里面输入地址） 也可以自己写一个简单的client来测试接口的使用。 12345678910111213public class ClientTest &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub JaxWsProxyFactoryBean bean = new JaxWsProxyFactoryBean(); bean.setAddress(\"http://localhost:8080/service/test?wsdl\"); bean.setServiceClass(TestService.class); TestService service = (TestService) bean.create(); String info = service.sayHello(); System.out.println(\"from service : \" + info); &#125;&#125; 小结采用springboot来搭建webservice是hin简单的，接口协议是http的哟~完整小栗子 注：我在开发中出现了一些错误（忘记把错误截图了，嘤嘤嘤~）确定代码没有问题的话，可以注意一下版本的问题。（springboot的版本我修改成了2.0.3，原来是2.1.3版本）","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"springboot","slug":"springboot","permalink":"http://yoursite.com/tags/springboot/"},{"name":"webservice","slug":"webservice","permalink":"http://yoursite.com/tags/webservice/"}]},{"title":"[leetcode]6-8题","slug":"leetcode-6-8题","date":"2019-03-30T14:09:24.000Z","updated":"2019-03-30T14:40:24.560Z","comments":true,"path":"2019/03/30/leetcode-6-8题/","link":"","permalink":"http://yoursite.com/2019/03/30/leetcode-6-8题/","excerpt":"ZigZag Conversion","text":"ZigZag Conversion1234567891011121314151617181920public String convert(String s, int numRows) &#123; if (numRows &lt;= 1) &#123;return s;&#125; int a = 2 * numRows - 2; StringBuilder sb = new StringBuilder(); for (int i = 0; i &lt; numRows; i++) &#123; if (i % numRows == 0 || (i+1) % numRows == 0) &#123; for (int j = i; j &lt; s.length(); j+=a) &#123; sb.append(s.charAt(j)); &#125; &#125;else &#123; for (int j = i; j &lt; s.length(); j+=a) &#123; sb.append(s.charAt(j)); if ((j + a - (j % a) * 2) &gt;= s.length()) &#123;continue;&#125; sb.append(s.charAt(j + a - (j % a) * 2)); &#125; &#125; &#125; return sb.toString();&#125; Reverse Integer 123456789101112131415public int reverse(int x) &#123; int rev = 0; while (x != 0) &#123; int pop = x % 10; x /= 10; if (rev &gt; Integer.MAX_VALUE/10 || (rev == Integer.MAX_VALUE / 10 &amp;&amp; pop &gt; 7)) &#123;return 0;&#125; if (rev &lt; Integer.MIN_VALUE/10 || (rev == Integer.MIN_VALUE / 10 &amp;&amp; pop &lt; -8)) &#123;return 0;&#125; rev = rev * 10 + pop; &#125; return rev;&#125; String to Integer (atoi) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123; public int myAtoi(String str) &#123; int re = 0; if (str.length() == 0) &#123; return 0; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; if(str.charAt(i) == ' ') &#123;continue;&#125; //跳过开头的所有空格 if (str.charAt(i) == '-') &#123; str = str.substring(i); if (str.length() == 1) &#123; return 0; &#125; i = 1; while (str.length() &gt; i &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123;i ++;&#125; //取到所有数字 str = str.substring(0,i); for (int j = 1; j &lt; str.length(); j++) &#123; if (re * (-1) &lt; Integer.MIN_VALUE / 10 || re*(-1) == Integer.MIN_VALUE / 10 &amp;&amp; str.charAt(j) &gt; '8') &#123; return Integer.MIN_VALUE; &#125;else &#123; re = re * 10 + str.charAt(j) - '0'; &#125; &#125; re = (-1) * re; &#125;else if (str.charAt(i) == '+') &#123; str = str.substring(i); if (str.length() == 1) &#123; return 0; &#125; i = 1; while (str.length() &gt; i &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123;i ++;&#125; //取到所有数字 str = str.substring(0,i); for (int j = 1; j &lt; str.length(); j++) &#123; if (re &gt; Integer.MAX_VALUE / 10 || re == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(j) &gt; '7') &#123; re = Integer.MAX_VALUE; &#125;else &#123; re = re * 10 + str.charAt(j) - '0'; &#125; &#125; &#125; else if (str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123; str = str.substring(i); i = 0; while (str.length() &gt; i &amp;&amp; str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123;i ++;&#125; //取到所有数字 str = str.substring(0,i); for (int j = 0; j &lt; str.length(); j++) &#123; if (re &gt; Integer.MAX_VALUE / 10 || re == Integer.MAX_VALUE / 10 &amp;&amp; str.charAt(j) &gt; '7') &#123; re = Integer.MAX_VALUE; &#125;else &#123; re = re * 10 + str.charAt(j) - '0'; &#125; &#125; &#125;else &#123; re = 0; &#125; break; &#125; return re; &#125;&#125; github地址","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"Netty入门：Tcp服务端","slug":"Netty入门：Tcp服务端","date":"2019-03-29T12:07:25.000Z","updated":"2019-03-29T13:32:00.639Z","comments":true,"path":"2019/03/29/Netty入门：Tcp服务端/","link":"","permalink":"http://yoursite.com/2019/03/29/Netty入门：Tcp服务端/","excerpt":"Netty是什么Netty是比较流行的NIO（非阻塞I/O）框架之一，是java NIO编程的首选框架。可以说每一个做Java后端开发的程序员都需要会用Netty框架。学习Netty框架推荐一本书：《Netty权威指南》 准备好Netty 下载Netty软件包：Netty官网 解压压缩包，里面包含了各个模块的.jar包和源码，我们只需要netty-all-5.0.0.Alphal.jar 搭建Netty应用工程，把jar加入工程即可","text":"Netty是什么Netty是比较流行的NIO（非阻塞I/O）框架之一，是java NIO编程的首选框架。可以说每一个做Java后端开发的程序员都需要会用Netty框架。学习Netty框架推荐一本书：《Netty权威指南》 准备好Netty 下载Netty软件包：Netty官网 解压压缩包，里面包含了各个模块的.jar包和源码，我们只需要netty-all-5.0.0.Alphal.jar 搭建Netty应用工程，把jar加入工程即可 Netty服务端开发从黑盒的角度来学习Netty框架，暂时不看源码，只了解怎么运用。 1.首先需要创建两个NIO线程组，专用于网络事件的处理。 12EventLoopGroup bossGroup = new NioEventLoopGroup();EventLoopGroup workerGroup = new NioEventLoopGroup(); 一个线程组用于服务端接受客户端的连接，另一个用于进行SocketChannel的网络读写。 2.创建ServerBootstrap对象 1ServerBootstrap b = new ServerBootstrap(); ServerBootstrap对象是Netty用于启动NIO服务端的辅助启动类，目的是降低服务端的开发复杂度。 3.配置辅助类 12345678910b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 1024) .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123; //IO事件的处理类 @Override protected void initChannel(SocketChannel ch) throws Exception &#123; ch.pipeline().addLast(new TCPTestHandler()); &#125; &#125;); 注意这里使用了匿名内部类，childHandler绑定的是I/O事件的处理类，主要用于处理网络I/O事件。 4.使用bind方法绑定监听端口，调用同步阻塞方法sync等待绑定操作完成，返回一个ChannelFuture对象，用于异步操作的通知回调。 12ChannelFuture future = b.bind(port).sync();future.channel().closeFuture().sync(); 5.退出线程组，释放资源。 12bossGroup.shutdownGracefully();workerGroup.shutdownGracefully(); 接下来，需要完成Handler类的实现。TCPTestHandler继承自ChannelInboundHandlerAdapter，用于对网络事件进行读写操作，即客户端传来的数据和服务端的应答数据都在Handler类进行处理。先看channelRead方法： 123456789ByteBuf buf = (ByteBuf) msg; //处理客户端传到服务端的数据byte[] req = new byte[buf.readableBytes()];buf.readBytes(req);String body = new String(req, \"utf-8\");System.out.println(\"The time server receive : \" + body);String data = \"服务端已接收\"; //返回应答消息byte[] rep = data.getBytes();ctx.writeAndFlush(Unpooled.copiedBuffer(rep)); 发生异常时的处理方法：123public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123; ctx.close();&#125; 小结通过前面的代码可以看出来，代码非常的简洁，开发难度也很低(主要参考《Netty权威指南》)。完整的Netty服务端代码","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"Netty","slug":"Netty","permalink":"http://yoursite.com/tags/Netty/"},{"name":"网络编程","slug":"网络编程","permalink":"http://yoursite.com/tags/网络编程/"}]},{"title":"百度地图处理大量坐标点","slug":"百度地图处理大量坐标点","date":"2019-03-19T13:44:18.000Z","updated":"2019-03-23T14:57:12.565Z","comments":true,"path":"2019/03/19/百度地图处理大量坐标点/","link":"","permalink":"http://yoursite.com/2019/03/19/百度地图处理大量坐标点/","excerpt":"海量数据点的处理在百度地图上标记点成千上万的时候，如果一次性把数据从后台传到前端，前端会加载的很慢或者直接不加载。为解决这个问题，百度地图提供了海量点和点聚合功能来处理。（点聚合，海量点） 遗留问题：如果同时使用海量点和点聚合会产生双重标记，目前还没有找到两种方法的组合使用形式。 但是当有十万个点以上的时候，海量点和点聚合还是会很卡顿。这时在海量点和点聚合的基础知识可以采用 分区加载 的方法。主要思路： 先获取可视界面的范围 在数据库中取出范围内的坐标点 数据传回前端显示 当地图发生拖拽和缩放事件时，需要删除原有的标注点，重新加载地图上的标注点。当地图的缩放等级越来越小还是需要在页面加载所有的点，解决办法是为地图设置一个最小缩放等级或者设置缩放等级到一固定值时就不再显示标注点。","text":"海量数据点的处理在百度地图上标记点成千上万的时候，如果一次性把数据从后台传到前端，前端会加载的很慢或者直接不加载。为解决这个问题，百度地图提供了海量点和点聚合功能来处理。（点聚合，海量点） 遗留问题：如果同时使用海量点和点聚合会产生双重标记，目前还没有找到两种方法的组合使用形式。 但是当有十万个点以上的时候，海量点和点聚合还是会很卡顿。这时在海量点和点聚合的基础知识可以采用 分区加载 的方法。主要思路： 先获取可视界面的范围 在数据库中取出范围内的坐标点 数据传回前端显示 当地图发生拖拽和缩放事件时，需要删除原有的标注点，重新加载地图上的标注点。当地图的缩放等级越来越小还是需要在页面加载所有的点，解决办法是为地图设置一个最小缩放等级或者设置缩放等级到一固定值时就不再显示标注点。 分区加载的代码实现使用上一篇介绍百度地图的文章中的功能就可以完成分区加载。前后端的交互可以采用ajax技术。这部分并没有技术难点，代码如下： 123456789101112131415161718192021222324252627282930313233var bounds = map.getBounds();var sw = bounds.getSouthWest();var ne = bounds.getNorthEast();var param = &#123; \"swlng\" : sw.lng, \"swlat\" : sw.lat, \"nelng\" : ne.lng, \"nelat\" : ne.lat&#125;; $.ajax(&#123; type: \"POST\", url: 地址, data: param, dataType: \"json\", success: function(jsonData)&#123; for(var i in jsonData)&#123; //console.log(jsonData[i].wgLat); //console.log(jsonData[i].wgLon); //console.log(jsonData[i].ip); var point = new BMap.Point(jsonData[i].wgLon,jsonData[i].wgLat); var marker = new BMap.Marker(point); var content = jsonData[i].ip; map.addOverlay(marker); //标注点击事件，在后面详细说明 addClickHandler(content,marker); &#125; var markerClusterer = new BMapLib.MarkerClusterer(map, &#123;markers:markers&#125;); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown)&#123; alert(errorThrown + ':' + textStatus); // 错误处理 &#125;&#125;); 点聚合+分区加载最简单的用法，生成一个marker数组，然后调用markerClusterer类即可。12345678910111213141516171819202122232425262728293031323334353637383940414243444546function reload()&#123; var bounds = map.getBounds(); var sw = bounds.getSouthWest(); var ne = bounds.getNorthEast(); var markers = []; var param = &#123; \"swlng\" : sw.lng, \"swlat\" : sw.lat, \"nelng\" : ne.lng, \"nelat\" : ne.lat &#125;; $.ajax(&#123; type: \"POST\", url: \"$&#123;pageContext.request.contextPath &#125;/MapServlet\", data: param, dataType: \"json\", success: function(jsonData)&#123; for(var i in jsonData)&#123; var point = new BMap.Point(jsonData[i].wgLon,jsonData[i].wgLat); var marker = new BMap.Marker(point); markers.push(marker); var content = jsonData[i].ip; //map.addOverlay(marker); addClickHandler(content,marker); &#125; var markerClusterer = new BMapLib.MarkerClusterer(map, &#123;markers:markers&#125;); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown)&#123; alert(errorThrown + ':' + textStatus); // 错误处理 &#125; &#125;);&#125;//标注点击事件function addClickHandler(content,marker)&#123; marker.addEventListener(\"click\",function(e)&#123; openInfo(content,e); &#125;);&#125; function openInfo(content,e)&#123; var p = e.target; var point = new BMap.Point(p.getPosition().lng, p.getPosition().lat); var infoWindow = new BMap.InfoWindow(content,opts); // 创建信息窗口对象 map.openInfoWindow(infoWindow,point); //开启信息窗口&#125; 海量点+分区加载海量点的加载速度比点聚合快一些，比较推荐。在使用海量点之前要先判断浏览器是否支持绘制海量点。123456if(document.createElement('canvas').getContext) //判断当前浏览器是否支持绘制海量点&#123; reload();&#125;else&#123; alert(\"本浏览器不支持绘制海量点\");&#125; 海量点自带点的绘制样式，不需要创建标注点（Marker）。该类属于覆盖物类，所以需要调用addOverlay()方法。1234567891011121314151617181920212223242526272829303132333435363738394041function reload()&#123; var points = []; //添加海量点数据 var bounds = map.getBounds(); var sw = bounds.getSouthWest(); var ne = bounds.getNorthEast(); var param = &#123; \"swlng\" : sw.lng, \"swlat\" : sw.lat, \"nelng\" : ne.lng, \"nelat\" : ne.lat &#125;; $.ajax(&#123; type: \"POST\", url: \"$&#123;pageContext.request.contextPath &#125;/MapServlet\", data: param, dataType: \"json\", success: function(jsonData)&#123; for(var i in jsonData)&#123; //console.log(jsonData[i].wgLat); //console.log(jsonData[i].wgLon); //console.log(jsonData[i].ip); var point = new BMap.Point(jsonData[i].wgLon,jsonData[i].wgLat); points.push(point); &#125; var options = &#123; size: BMAP_POINT_SIZE_NORMAL, shape: BMAP_POINT_SHAPE_STAR, color: '#d340c3' &#125; var pointCollection = new BMap.PointCollection(points, options); pointCollection.addEventListener(\"click\",function(e)&#123; alert('该点的坐标为：' + e.point.lng + ',' + e.point.lat); &#125;); map.addOverlay(pointCollection); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown)&#123; alert(errorThrown + ':' + textStatus); // 错误处理 &#125; &#125;);&#125; 百度地图处理海量点完整实例","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"http://yoursite.com/tags/百度地图/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"百度地图JavaScript API基本用法","slug":"百度地图JavaScript-API基本用法","date":"2019-03-18T11:42:16.000Z","updated":"2019-03-18T12:11:06.986Z","comments":true,"path":"2019/03/18/百度地图JavaScript-API基本用法/","link":"","permalink":"http://yoursite.com/2019/03/18/百度地图JavaScript-API基本用法/","excerpt":"百度地图坐标系在介绍百度地图的使用之前，需要先了解三种不同的坐标系： WGS84：国际标准坐标系，又称大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。 GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。腾讯，高德地图使用该种坐标系。 BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。 非中国地区地图，服务坐标统一使用WGS84坐标。 在使用百度地图之前，要把非百度坐标转换成百度坐标。可以使用百度提供的转换API，也可以在网上检索转换的方法。 百度API的地址： 百度坐标转换示例 Java实现三种坐标系的转换：坐标系转换示例","text":"百度地图坐标系在介绍百度地图的使用之前，需要先了解三种不同的坐标系： WGS84：国际标准坐标系，又称大地坐标系，也是目前广泛使用的GPS全球卫星定位系统使用的坐标系。 GCJ02：又称火星坐标系，是由中国国家测绘局制订的地理信息系统的坐标系统。由WGS84坐标系经加密后的坐标系。腾讯，高德地图使用该种坐标系。 BD09：为百度坐标系，在GCJ02坐标系基础上再次加密。其中bd09ll表示百度经纬度坐标，bd09mc表示百度墨卡托米制坐标。 非中国地区地图，服务坐标统一使用WGS84坐标。 在使用百度地图之前，要把非百度坐标转换成百度坐标。可以使用百度提供的转换API，也可以在网上检索转换的方法。 百度API的地址： 百度坐标转换示例 Java实现三种坐标系的转换：坐标系转换示例 百度地图的展示百度地图的接口是永久免费的，只需要申请成为百度开发者获取密钥就可以使用百度地图强大的功能。这里提供官方开发文档地址： 百度地图JavaScript API 1.使用之前确保你已经获得密钥，在页面的的头部引用百度地图的API文件：1234&lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=3.0&amp;ak=你的密钥\"&gt;&lt;/script&gt;//这样不需要密钥也可以引用百度地图，但是有些功能貌似无法实现&lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=1.1&amp;services=false\"&gt;&lt;/script&gt; 2.编写百度地图的容器，让地图充满整个网页： 1234567891011121314&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;meta name=\"viewport\" content=\"initial-scale=1.0, user-scalable=no\" /&gt; &lt;script type=\"text/javascript\" src=\"http://api.map.baidu.com/api?v=3.0&amp;ak=你的密钥\"&gt;&lt;/script&gt; &lt;title&gt;测试&lt;/title&gt; &lt;style type=\"text/css\"&gt; html&#123;height:100%&#125; body&#123;height:100%;margin:0px;padding:0px&#125; #allmap&#123;height:100%&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"allmap\"&gt;&lt;/div&gt;&lt;/body&gt; 如果地图没有正常显示，查看报错信息是有关于icon的，就在头部添加：1&lt;link rel=\"shortcut icon\" href=\"img/bitbug_favicon2.ico\" /&gt; href里面的地址如果不存在，他不会报错，会发出警告，所以不需要去创建.ico文件。 3.创建map实例： 1234567891011var map = new BMap.Map(\"allmap\"); // 创建Map实例// 初始化地图,设置中心点坐标和地图级别,这里设置的是天安门为中心点map.centerAndZoom(new BMap.Point(116.404, 39.915), 17); //添加地图类型控件map.addControl(new BMap.MapTypeControl(&#123; mapTypes:[ BMAP_NORMAL_MAP, BMAP_HYBRID_MAP ]&#125;));map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放map.addControl(new BMap.NavigationControl()); //添加平移缩放控件 更多地图的控件查看JavaScript API v3.0类参考 用浏览器打开html文件，就可以看到最基本的地图界面。 百度地图还支持自定义地图样式，参考：个性化地图 百度地图的使用仅仅一张地图显然不满足要求，百度地图还提供了各种各样的功能，记录几个基本的功能。1.标注点 1234567//在point点创建标注var marker = new BMap.Marker(point);//将标注添加到地图中map.addOverlay(marker); //删除地图上所有的标注点map.clearOverlays(); 2.信息窗口 1234567891011var opts = &#123; width : 250, // 信息窗口宽度 height: 100, // 信息窗口高度 title : \"Hello\" // 信息窗口标题 &#125; //实例化信息窗口var infoWindow = new BMap.InfoWindow(\"World\", opts); //为标注点绑定事件marker.addEventListener(\"click\", function()&#123; map.openInfoWindow(infoWindow,point); //开启信息窗口 &#125;); 3.事件处理 123//addEventListener方法有两个参数：监听的事件名称和事件触发时调用的函数。map.addEventListener(\"click\", function()&#123;&#125;); 4.获取地图信息 123456//获取地图当前缩放等级var zoom = map.getZoom();//获取所示地图经纬度范围var bounds = map.getBounds(); //获取地图可视界面var sw = bounds.getSouthWest(); //获取左下角坐标var ne = bounds.getNorthEast(); //获取右上角坐标 百度地图基本用法实例","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"百度地图","slug":"百度地图","permalink":"http://yoursite.com/tags/百度地图/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"[电影]那些年，一直温暖我们的夏目","slug":"电影-那些年，一直温暖我们的夏目","date":"2019-03-10T08:57:03.000Z","updated":"2019-03-10T09:25:50.927Z","comments":true,"path":"2019/03/10/电影-那些年，一直温暖我们的夏目/","link":"","permalink":"http://yoursite.com/2019/03/10/电影-那些年，一直温暖我们的夏目/","excerpt":"&emsp;&emsp;昨天晚上和朋友相约去看了夏目剧场版：夏目友人帳 ～うつせみに結ぶ～，这篇文章不算影评，只是一篇分享。会提及一部分影片内容。","text":"&emsp;&emsp;昨天晚上和朋友相约去看了夏目剧场版：夏目友人帳 ～うつせみに結ぶ～，这篇文章不算影评，只是一篇分享。会提及一部分影片内容。 1&emsp;&emsp;昨天看完电影，一直等到ed结束才离开座位，我确实在等彩蛋，虽然没有（滑稽）&emsp;&emsp;看过夏目的人都知道，夏目是由一个个治愈的小故事组成，在看开头部分的时候，我以为电影也是一样，由3到4个小故事组成（没有看过预告和简介的我总是特别的天真），毕竟开头真的是TV版的味道。看到主线的时候才恍然大悟，原来前面的都是引子。 2&emsp;&emsp;众所周知，夏目的标签是治愈，身受神罚的穗之影被认为是夺取人们记忆的大妖，其实他才是最痛苦的，一旦他离开，所有人不会记得他，但是他记得所有人。所以他不敢在一个地方停留太久，因为会舍不得，这就是夏目一直想传达给观众的“羁绊”，人与人之间的，人与物之间的羁绊。&emsp;&emsp;剧版有一集讲述的一个小茶杯，与人类生活久了，被丢掉了，仍然要回到人类的房子，他成了精，没什么高深的法力，却愿意为人类挡一次灾难。夏目的故事就是这样，不恐怖，不惊悚，温馨且有趣。&emsp;&emsp;再说到记忆，17年看了一部电影《寻梦环游记》，讲的是记忆与存在，当一个人被所有人忘记的时候，他就真的消散了，就像他没有来过这世间。穗之影来过，可是没有人记得他；幸好，夏目不受影响，夏目还记得他也是一个很温暖的人，他带给容莉枝美好的8年时光还会出现在容莉枝的梦里。&emsp;&emsp;玲子曾说，我才不要被人记住，我宁愿就像没有存在过。但是她被所有妖怪记得，被容莉枝记得，被夏目贵志记得。我想玲子和夏目一样，都看得见妖怪，能看见别人看不到的另一个世界。在影片开始提到的那个假装自己看得见妖怪的结城，在森林深处，夏目看到的是水花飞溅的瀑布，结城看到的是光秃秃的石壁。这就是两个世界，夏目和玲子能看到另一个世界。在外人看来是虚拟的，但在他们身上是真实的感受，所以，他们被人用怪异的目光打量。&emsp;&emsp;但是夏目更幸运，他遇到了温柔的滋叔叔和塔子阿姨，遇到了口嫌体正直的斑，还有一些多轨那样的朋友。只有一个人的玲子只能把自己包裹起来，让自己变得坚强，因为钦佩她而害羞跑掉的容莉枝会被她认为是害怕，但是玲子仍然保留着那个铃铛。玲子也是一个内心很温柔的人，也比夏目更让人心疼。&emsp;&emsp;影片最后，消散的穗之影，所有看不见妖怪的人都不会记得他，但是他给了人们一场飞絮。飞絮复制生物的外形又消散，这是影片最有情怀的画面，这是所有普通人都看见妖怪的瞬间。&emsp;&emsp;希望喜欢夏目的你，能学会温柔的对待世界，同时被世界温柔以待。 3&emsp;&emsp;抛开剧情和主题，影片的“萌”简直犯规了。 &emsp;&emsp;贪吃的猫咪老师；有丝分裂的一，二，三号；叠在一起才可以说话的设定，为这部影片添加了更多的精彩。作画的老师真的特别的心细，我觉得猫咪老师真的越来越胖了（因为腿越来越短了）","categories":[{"name":"live","slug":"live","permalink":"http://yoursite.com/categories/live/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"动漫","slug":"动漫","permalink":"http://yoursite.com/tags/动漫/"}]},{"title":"[leetcode]1-5题","slug":"leetcode-1-5题","date":"2019-03-09T15:17:12.000Z","updated":"2019-03-30T14:37:28.443Z","comments":true,"path":"2019/03/09/leetcode-1-5题/","link":"","permalink":"http://yoursite.com/2019/03/09/leetcode-1-5题/","excerpt":"这个系列的文章是我在刷leetcode的题的记录，包括解题思路和代码。github地址 Tow Sum","text":"这个系列的文章是我在刷leetcode的题的记录，包括解题思路和代码。github地址 Tow Sum123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = new int[2]; for(int i=0; i&lt;nums.length; i++)&#123; for(int j=i+1; j&lt;nums.length; j++)&#123; if(nums[i] + nums[j] == target)&#123; result[0] = i; result[1] = j; break; &#125; &#125; &#125; return result; &#125;&#125; 这道题没有什么好说的，简单的枚举就可以完成。 Add Two Numbers 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; if(l1 == null || l2 == null) return null; ListNode l = new ListNode(0); ListNode temp = l; int mark = 0; while(true)&#123; int value = 0; if(mark == 1)&#123; value = 1 + l1.val + l2.val; mark = 0; &#125;else value = l1.val + l2.val; if(value &gt;= 10)&#123; value = value - 10; mark = 1; &#125; temp.next = new ListNode(value); l1 = l1.next; l2 = l2.next; temp = temp.next; if(l1 == null &amp;&amp; l2 == null)&#123; if(mark == 0) break; &#125; if(l1 == null)&#123; l1 = new ListNode(0); &#125; if(l2 == null)&#123; l2 = new ListNode(0); &#125; &#125; return l.next; &#125; &#125; Longest Substring Without Repeating Characters 1234567891011121314151617181920class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; List&lt;Character&gt; result = new ArrayList(); int count = 0; char[] cs = s.toCharArray(); for(int i = 0; i &lt; cs.length; i ++)&#123; result.add(cs[i]); for(int j = i+1; j&lt;cs.length; j++)&#123; if(result.indexOf(cs[j]) != -1) break; result.add(cs[j]); &#125; if(result.size() &gt; count) count = result.size(); result.clear(); &#125; return count; &#125;&#125; Median of Two Sorted Arrays 12345678910111213141516171819202122class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; List&lt;Integer&gt; list = new ArrayList(); for(int i : nums1) list.add(i); for(int i : nums2) list.add(i); Collections.sort(list); Object[] arr = list.toArray(); if(arr.length % 2 == 0)&#123; int index = arr.length / 2; int p = (int)arr[index - 1]; int n = (int)arr[index]; return (p+n) / 2.0; &#125;else&#123; int index = arr.length / 2; return (int)arr[index]; &#125; &#125;&#125; Longest Palindromic Substring 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123; public String longestPalindrome(String s)&#123; if(s.length() == 0)&#123; return \"\"; &#125; String result = s.charAt(0)+\"\"; for (int i = 0; i &lt; s.length(); i++) &#123; for (int j = i+1; j &lt; s.length(); j++) &#123; String temp = s.substring(i, j+1); boolean mark = true; if(temp.length() % 2 == 0) &#123; int index = temp.length() / 2; for (int k = index; k &lt; temp.length(); k++) &#123; if (temp.charAt(k) != temp.charAt(temp.length()-1-k)) &#123; mark = false; break; &#125; &#125; &#125;else &#123; int index = temp.length() / 2; for (int k = index+1; k &lt; temp.length(); k++) &#123; if (temp.charAt(k) != temp.charAt(temp.length()-1-k)) &#123; mark = false; break; &#125; &#125; &#125; if(mark) &#123; if (result.length() &lt; temp.length()) &#123; result = temp; &#125; &#125; &#125; &#125; return result; &#125;&#125;","categories":[{"name":"code","slug":"code","permalink":"http://yoursite.com/categories/code/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"}]},{"title":"[视频]值得一看的广告","slug":"视频-值得一看的广告","date":"2019-03-05T13:44:09.000Z","updated":"2019-03-08T15:45:57.449Z","comments":true,"path":"2019/03/05/视频-值得一看的广告/","link":"","permalink":"http://yoursite.com/2019/03/05/视频-值得一看的广告/","excerpt":"Dream Crazy希望你花2分钟看完这个广告： 2018年是 “Just Do It” 口号诞生的30周年，耐克推出了名为 “Dream Crazy” 的一则广告，广告云集了各路耐克旗下的大咖，秉承一贯的励志风格，从头燃到尾，我节选了一段： If people say your dreams are crazyIf they laugh at what you think you can doGood, stay that wayBecause what non-believers fail to understand is thatCalling a dream crazy is not an insultIt’s a compliment 之后是对疯狂的梦的具体阐述。当你想做一件事，不仅仅要去做，还要做到最好；当你羡慕其他人正在做的事，不仅仅看，还要加入他们；当你成为第一，不仅仅满足，还要成为传奇，甚至利用自己的影响力为社会做点什么。","text":"Dream Crazy希望你花2分钟看完这个广告： 2018年是 “Just Do It” 口号诞生的30周年，耐克推出了名为 “Dream Crazy” 的一则广告，广告云集了各路耐克旗下的大咖，秉承一贯的励志风格，从头燃到尾，我节选了一段： If people say your dreams are crazyIf they laugh at what you think you can doGood, stay that wayBecause what non-believers fail to understand is thatCalling a dream crazy is not an insultIt’s a compliment 之后是对疯狂的梦的具体阐述。当你想做一件事，不仅仅要去做，还要做到最好；当你羡慕其他人正在做的事，不仅仅看，还要加入他们；当你成为第一，不仅仅满足，还要成为传奇，甚至利用自己的影响力为社会做点什么。 Colin Kaepernick广告成为2018年美国最受争议的广告，就是因为广告的主角——前NFL球星 Colin Kaepernick。可能你不知道他是谁，他做了什么，他为什么有争议，在这里，为大家做一个简单介绍： Colin Kaepernick是一名橄榄球球员，是NFL旧金山49人队四分卫。 2016年，Collin Kaepernick 在赛前演奏国歌时上演他单膝跪地的特殊动作，而这个动作旨在抗议种族歧视、社会不平等和警方暴行。 当时他的场上抗议动作惹怒了美国总统，NFL所有球队的高层认为他的举动会为球队招致谩骂和祸端。 直至2018年，他失业两年。 在2016年8月份，发生了一系列美国警察滥权枪杀非裔美国男性的事件，此后，卡佩尼克就开始在旧金山49人赛前的国歌演奏阶段坐在板凳上，后来直接单膝跪地。他解释道，自己是在努力声援那些没有机会去发声的被枪杀同胞们。从这个角度，Colin Kaepernick的经历与广告主题相吻合。当然，耐克决定卡佩尼克领衔“Just do it”三十周年广告宣传片也有自己的利益考量。无视政治立场和利益因素，这则30周年广告无疑今年是最好的广告。 Just Do ItWieden &amp; Kennedy（耐克长期合作的广告公司）极力推荐科林·卡佩尼克作为耐克 “Just Do It” 三十周年纪念活动的封面人物，该公司的一位设计师9月份在一个网站上展示自己的作品时说道：“耐克同意了，我们做了，科林推了，人们疯了。”。可见，耐克的这一做法也契合了主题。2018年年初，据《纽约时报》以及其他新闻媒体报道，耐克公司内部为其女性员工营造了一个充满敌意与歧视的工作环境。8月份，两名耐克前女性雇员提起集体诉讼，指控该公司在薪资平等、职位升迁等方面存在性别歧视的的行为。而这次广告活动则为耐克赢得了一波好评。同时，为大家推荐一则关于crazy的广告。 最后引用广告词作为结尾： So don’t ask if your dreams are crazyAsk if they’re crazy enoughIt’s only crazy until you do itJust Do It","categories":[{"name":"live","slug":"live","permalink":"http://yoursite.com/categories/live/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"},{"name":"广告","slug":"广告","permalink":"http://yoursite.com/tags/广告/"},{"name":"Nick","slug":"Nick","permalink":"http://yoursite.com/tags/Nick/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-03-03T13:02:51.088Z","updated":"2019-03-03T13:02:51.088Z","comments":true,"path":"2019/03/03/hello-world/","link":"","permalink":"http://yoursite.com/2019/03/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}